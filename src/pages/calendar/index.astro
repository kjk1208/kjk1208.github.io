---
import BaseLayout from "../../layouts/BaseLayout.astro";
import { AUTH, CALENDAR } from "../../site.config";
---

<style is:global>
  /* FullCalendar CSS는 CDN으로 전역 주입 (패키지 CSS import 금지) */
  @import url("https://cdn.jsdelivr.net/npm/@fullcalendar/common@6.1.19/main.min.css");
  @import url("https://cdn.jsdelivr.net/npm/@fullcalendar/daygrid@6.1.19/main.min.css");
</style>

<BaseLayout title="달력">
  <h1>달력</h1>

  <!-- (비로그인) 공개 캘린더 임베드 -->
  <section class="card only-signed-out" id="public-embed">
    <p class="small">로그인하면 내 캘린더를 읽고/쓸 수 있습니다.</p>
    <div style="overflow:hidden">
      <iframe
        src={`https://calendar.google.com/calendar/embed?src=${encodeURIComponent(CALENDAR.id)}&ctz=${encodeURIComponent(CALENDAR.timezone)}&mode=MONTH`}
        style="width:100%; height:70vh; border:0" loading="lazy">
      </iframe>
    </div>
  </section>

  <!-- (로그인) 달력 뷰 + 쓰기 버튼 -->
  <section class="card only-signed-in">
    <div>
      <strong>내 캘린더 (primary)</strong>
      <div class="small">주인장 계정으로 로그인해야만 캘린더가 보입니다.</div>
    </div>
    <div id="owner-actions" style="display:none; gap:.5rem;">
      <button class="button" id="btnCreate">이벤트 만들기</button>
    </div>
    <hr class="sep" />
    <div id="calendar" style="min-height: 650px;"></div>
  </section>

  <!-- ✅ FullCalendar JS (CDN, 글로벌 객체) -->
  <script is:inline src="https://cdn.jsdelivr.net/npm/@fullcalendar/core@6.1.19/index.global.min.js"></script>
  <script is:inline src="https://cdn.jsdelivr.net/npm/@fullcalendar/daygrid@6.1.19/index.global.min.js"></script>

  <!-- ✅ 캘린더 초기화 + Google Calendar에서 이벤트 불러오기 -->
  <script is:inline>
    // 로그인 토큰
    function getAccessToken() {
      const t = localStorage.getItem("access_token");
      const exp = Number(localStorage.getItem("token_exp") || 0);
      return (t && exp > Date.now()) ? t : null;
    }

    document.addEventListener("DOMContentLoaded", () => {
      const token = getAccessToken();

      // 로그인 상태면 공개 임베드 제거
      if (token) document.getElementById('public-embed')?.remove();

      const el = document.getElementById("calendar");
      if (!el || !token) return; // 비로그인: 공개 임베드만 보임

      // 전역 확인 (global build)
      const FC = window.FullCalendar;
      // daygrid 전역은 환경에 따라 FullCalendar.DayGrid 만 존재할 수 있음
      const DayGrid = FC?.DayGrid || window.FullCalendarDayGrid || null;

      if (!FC) {
        console.error("FullCalendar core(global)가 아직 로드되지 않았습니다.");
        return;
      }

      // 기본 옵션
      const options = {
        initialView: "dayGridMonth",
        locale: "ko",
        firstDay: 0,
        height: "auto",
        headerToolbar: { left: "prev,next today", center: "title", right: "" },

        // FullCalendar가 화면에 보여주는 범위로 Google Calendar에서 이벤트 로드
        events: async (info, success, failure) => {
          try {
            const url = new URL("https://www.googleapis.com/calendar/v3/calendars/primary/events");
            url.searchParams.set("singleEvents", "true");
            url.searchParams.set("orderBy", "startTime");
            url.searchParams.set("timeMin", new Date(info.start).toISOString());
            url.searchParams.set("timeMax", new Date(info.end).toISOString());

            const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
            if (!res.ok) {
              const txt = await res.text().catch(()=> "");
              console.error("Calendar API error:", res.status, txt);
              failure(new Error(txt || "Calendar API error"));
              return;
            }
            const { items = [] } = await res.json();
            const evts = items.map(e => ({
              id: e.id,
              title: e.summary || "(제목 없음)",
              start: e.start?.dateTime || e.start?.date,
              end:   e.end?.dateTime   || e.end?.date,
              allDay: !!e.start?.date
            }));
            success(evts);
          } catch (err) {
            failure(err);
          }
        }
      };

      // ✅ 플러그인 전역이 확인될 때만 plugins 옵션을 추가 (없으면 자동등록에 맡김)
      if (DayGrid) {
        options.plugins = [ DayGrid ];
      } else {
        console.warn("DayGrid 플러그인 전역을 찾지 못했습니다. (스크립트 포함시 자동등록을 기대합니다)");
      }

      const calendar = new FC.Calendar(el, options);
      calendar.render();

      // (선택) OWNER에게만 "이벤트 만들기" 버튼 노출하고 생성 기능 연결
      const ownerMeta = document.getElementById('auth-config');
      const OWNER = ownerMeta?.dataset.owner || "";
      const userEmail = localStorage.getItem("user_email") || "";

      if (userEmail && OWNER && userEmail === OWNER) {
        const ownerActions = document.getElementById('owner-actions');
        if (ownerActions) {
          ownerActions.style.display = "flex";
          document.getElementById('btnCreate')?.addEventListener('click', async () => {
            const start = new Date(Date.now() + 60*60*1000).toISOString();
            const end   = new Date(Date.now() + 2*60*60*1000).toISOString();
            const res = await fetch("https://www.googleapis.com/calendar/v3/calendars/primary/events", {
              method: "POST",
              headers: {
                Authorization: `Bearer ${token}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                summary: "테스트 이벤트",
                start: { dateTime: start, timeZone: "Asia/Seoul" },
                end:   { dateTime: end,   timeZone: "Asia/Seoul" }
              })
            });
            if (!res.ok) {
              const t = await res.text().catch(()=> "");
              alert("생성 실패:\n" + t);
              return;
            }
            alert("이벤트 생성 완료!");
            calendar.refetchEvents();
          });
        }
      }
    });
  </script>

  <style is:global>
    #calendar :global(.fc) {
      --fc-border-color: var(--border);
      --fc-button-bg-color: var(--surface);
      --fc-button-text-color: var(--fg);
      --fc-button-border-color: var(--border);
      --fc-page-bg-color: var(--surface);
      --fc-neutral-bg-color: var(--surface);
      --fc-list-event-hover-bg-color: var(--surface);
    }
  </style>
</BaseLayout>
