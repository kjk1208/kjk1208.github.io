---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { AUTH, CALENDAR } from '../../site.config';
---
<BaseLayout title="달력">
  <h1>달력</h1>

  <!-- (비로그인) 공개 캘린더 임베드 -->
  <!-- ✅ 로그인하면 이 섹션을 DOM에서 제거하여 CSP 경고 방지 -->
  <section class="card only-signed-out" id="public-embed">
    <p class="small">로그인하면 내 캘린더를 읽고/쓸 수 있습니다.</p>
    <div style="overflow:hidden">
      <iframe
        src={`https://calendar.google.com/calendar/embed?src=${encodeURIComponent(CALENDAR.id)}&ctz=${encodeURIComponent(CALENDAR.timezone)}&mode=MONTH`}
        style="width:100%; height:70vh; border:0" loading="lazy">
      </iframe>
    </div>
  </section>

  <!-- (로그인) API로 읽기/쓰기 -->
  <section class="card only-signed-in">
    <div style="display:flex; gap:.5rem; align-items:center; justify-content:space-between; flex-wrap:wrap;">
      <div>
        <strong>내 캘린더 (primary)</strong>
        <div class="small">로그인 계정이 <code>{AUTH.ownerEmail}</code>일 때만 “이벤트 만들기”가 보입니다.</div>
      </div>
      <div id="owner-actions" style="display:none; gap:.5rem;">
        <button class="button" id="btnCreate">이벤트 만들기</button>
      </div>
    </div>
    <hr class="sep" />
    <div id="events">불러오는 중…</div>
  </section>

  <script>
    // BaseLayout의 <meta id="auth-config" ...>에서 값 읽기
    const OWNER = document.getElementById('auth-config')?.dataset.owner || "";

    // 토큰 헬퍼
    function getAccessToken() {
      const t = localStorage.getItem("access_token");
      const exp = Number(localStorage.getItem("token_exp") || 0);
      return (t && exp > Date.now()) ? t : null;
    }

    async function fetchMe(token) {
      try {
        const r = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
          headers: { Authorization: `Bearer ${token}` }
        });
        if (!r.ok) return {};
        return r.json();
      } catch { return {}; }
    }

    async function loadEvents(token) {
      const eventsBox = document.getElementById('events');
      const url = new URL("https://www.googleapis.com/calendar/v3/calendars/primary/events");
      const now = Date.now();
      url.searchParams.set("singleEvents", "true");
      url.searchParams.set("orderBy", "startTime");
      url.searchParams.set("timeMin", new Date(now - 7*86400*1000).toISOString());
      url.searchParams.set("timeMax", new Date(now + 30*86400*1000).toISOString());

      try {
        const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
        if (!res.ok) {
          // ✅ 403 원인 파악용 상세 로그
          const txt = await res.text().catch(()=> "");
          console.error("Calendar API error:", res.status, txt);
          // granted scopes 확인
          try {
            const ti = await fetch(`https://www.googleapis.com/oauth2/v3/tokeninfo?access_token=${token}`).then(r=>r.json());
            console.log("granted scopes:", ti.scope);
          } catch {}
          eventsBox.innerHTML = `<p>이벤트 불러오기 실패 (${res.status}).<br/><code style="white-space:pre-wrap">${(txt||"").replace(/</g,"&lt;")}</code></p>`;
          return;
        }
        const { items = [] } = await res.json();
        eventsBox.innerHTML = items.length
          ? `<ul style="margin:0; padding-left:1rem">${items.map(e=>{
              const start=e.start?.dateTime||e.start?.date||''; const end=e.end?.dateTime||e.end?.date||'';
              return `<li><strong>${e.summary||'(제목 없음)'}</strong> — ${start}${end?' ~ '+end:''}</li>`;
            }).join("")}</ul>`
          : "<p>예정된 이벤트가 없습니다.</p>";
      } catch (e) {
        console.error(e);
        eventsBox.textContent = "네트워크 오류로 이벤트를 불러오지 못했습니다.";
      }
    }

    async function createEvent(token) {
      const start = new Date(Date.now() + 60*60*1000).toISOString();
      const end   = new Date(Date.now() + 2*60*60*1000).toISOString();
      try {
        const res = await fetch("https://www.googleapis.com/calendar/v3/calendars/primary/events", {
          method: "POST",
          headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" },
          body: JSON.stringify({
            summary: "테스트 이벤트",
            start: { dateTime: start, timeZone: "Asia/Seoul" },
            end:   { dateTime: end,   timeZone: "Asia/Seoul" },
          })
        });
        if (!res.ok) {
          const t = await res.text().catch(()=> "");
          alert("생성 실패:\n" + t);
          return;
        }
        alert("이벤트 생성 완료!");
        await loadEvents(token);
      } catch (e) {
        alert("네트워크 오류로 생성 실패");
        console.error(e);
      }
    }

    async function main() {
      const token = getAccessToken();

      // ✅ 로그인 상태라면 공개 임베드 섹션 제거(CSP 경고 방지)
      if (token) {
        const pub = document.getElementById('public-embed');
        pub?.parentNode?.removeChild(pub);
      }

      if (!token) return; // 비로그인: 공개 임베드만 표시

      const me = await fetchMe(token);
      await loadEvents(token);

      // 관리자만 쓰기 버튼 표시
      if (me?.email === OWNER) {
        const ownerActions = document.getElementById('owner-actions');
        ownerActions.style.display = "flex";
        document.getElementById('btnCreate')?.addEventListener('click', ()=>createEvent(token));
      }
    }
    main();
  </script>
</BaseLayout>
